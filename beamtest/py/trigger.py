import os.path
import numpy as np
import pandas as pd

names = [ 
    'UtcTime'   , # UTC Time (datetime64[ns])
    'EventID'   , # EventID + 0x8000 0000(MSB)
    'NtrgLck'   , # Number of issued Trigger Acknowledge
    'NclkPps'   , # System clock count at GpsPPS received (50MHz)
    'NclkRaw'   , # System clock count (50MHz)
    'NclkEna'   , # System clock count during Trigger Enable (50MHz)
    'NclkLiv'   , # System clock count during Trigger Module is ready (50MHz)
    'NgpsPPS'   , # Number of received GpsPPS signal
    'CoHitRw'   , # Coincidence Hit Flag
    'CoHitCD'   , # Coincidence Count Down Hit Flag
    'HitPatt'   , # Detector Hit Pattern
    'Tsecond'   , # Epoch Time (s) no correction
    'Tmicros'   , # Epoch Time (us) no correction
    'NtrgAck'   , # Number of Trigger Acknowledge 
    'NswtAck'   , # Number of Trigger Acknowledge generated by the switch on board
    'NextAck'   , # Number of Trigger Acknowledge generated by the internal clock
    'NlpcAck'   , # Number of Trigger Acknowledge getenared by the external signal on LPC
    'NhpcAck'   , # Number of Trigger Acknowledge generated by the external signal on HPC
    'NcoMode[0]', 'NcdMode[0]', #
    'NcoMode[1]', 'NcdMode[1]', # 
    'NcoMode[2]', 'NcdMode[2]', #
    'NcoMode[3]', 'NcdMode[3]', # NcoMode[%x]:
    'NcoMode[4]', 'NcdMode[4]', #  Number of coincidence 
    'NcoMode[5]', 'NcdMode[5]', #  generated by raw hit
    'NcoMode[6]', 'NcdMode[6]', #
    'NcoMode[7]', 'NcdMode[7]', #
    'NcoMode[8]', 'NcdMode[8]', #
    'NcoMode[9]', 'NcdMode[9]', # NcdMode[%x]:
    'NcoMode[a]', 'NcdMode[a]', #  Number of coincidence 
    'NcoMode[b]', 'NcdMode[b]', #  generated by CD hit 
    'NcoMode[c]', 'NcdMode[c]', #
    'NcoMode[d]', 'NcdMode[d]', #
    'NcoMode[e]', 'NcdMode[e]', #
    'NcoMode[f]', 'NcdMode[f]', #
    'NhitACD'   , # Number of ACD hit
    'NoneSiT'   , # Number of Si-Tracker hit. Any one layer hit (either X or Y signal)
    'NandSiT'   , # Number of Si-Tracker hit. Any one layer hit (both X and Y signal)
    'NtwoSiT'   , # Number of Si-Tracker hit. Any of two layer hit (either X or Y signal)
    'NhitCZT'   , # Number of CZT hit
    'N1stCsI'   , # Number of CsI hit from 1st FEE
    'N2ndCsI'   , # Number of CsI hit form 2nd FEE (Currently disabled)
    'NhitXsi[0]', 'NhitYsi[0]', #
    'NhitXsi[1]', 'NhitYsi[1]', #
    'NhitXsi[2]', 'NhitYsi[2]', #
    'NhitXsi[3]', 'NhitYsi[3]', # NhitXsi[%x]:
    'NhitXsi[4]', 'NhitYsi[4]', #  Number of X-axis hit
    'NhitXsi[5]', 'NhitYsi[5]', #
    'NhitXsi[6]', 'NhitYsi[6]', #
    'NhitXsi[7]', 'NhitYsi[7]', # NhitYsi[%x]:
    'NhitXsi[8]', 'NhitYsi[8]', #  Number of Y-axis hit
    'NhitXsi[9]', 'NhitYsi[9]', #
    'NhitXsi[a]', 'NhitYsi[a]', #
    'NhitXsi[b]', 'NhitYsi[b]', #
    'EoC'         # EoC: End of Column. Always 0xFFFF FFFF
]       

dtype = { 
    # 'UtcTime'   : datetime64[ns], # UTC Time (datetime64[ns])
    'UtcTime'   : np.uint64, # UTC Time (datetime64[ns])
    'EventID'   : np.uint32, # EventID + 0x8000 0000(MSB)
    'NtrgLck'   : np.uint32, # Number of issued Trigger Acknowledge
    'NclkPps'   : np.uint32, # System clock count at GpsPPS received (50MHz)
    'NclkRaw'   : np.uint32, # System clock count (50MHz)
    'NclkEna'   : np.uint32, # System clock count during Trigger Enable (50MHz)
    'NclkLiv'   : np.uint32, # System clock count during Trigger Module is ready (50MHz)
    'NgpsPPS'   : np.uint32, # Number of received GpsPPS signal
    'CoHitRw'   : np.uint16, # Coincidence Hit Flag
    'CoHitCD'   : np.uint16, # Coincidence Count Down Hit Flag
    'HitPatt'   : np.uint32, # Detector Hit Pattern
    'Tsecond'   : np.uint32, # Epoch Time (s) no correction
    'Tmicros'   : np.uint32, # Epoch Time (us) no correction
    'NtrgAck'   : np.uint32, # Number of Trigger Acknowledge 
    'NswtAck'   : np.uint32, # Number of Trigger Acknowledge generated by the switch on board
    'NextAck'   : np.uint32, # Number of Trigger Acknowledge generated by the internal clock
    'NlpcAck'   : np.uint32, # Number of Trigger Acknowledge getenared by the external signal on LPC
    'NhpcAck'   : np.uint32, # Number of Trigger Acknowledge generated by the external signal on HPC
    'NcoMode[0]': np.uint16, 'NcdMode[0]': np.uint16, #
    'NcoMode[1]': np.uint16, 'NcdMode[1]': np.uint16, # 
    'NcoMode[2]': np.uint16, 'NcdMode[2]': np.uint16, #
    'NcoMode[3]': np.uint16, 'NcdMode[3]': np.uint16, # NcoMode[%x]:
    'NcoMode[4]': np.uint16, 'NcdMode[4]': np.uint16, #  Number of coincidence
    'NcoMode[5]': np.uint16, 'NcdMode[5]': np.uint16, #  generated by raw hit
    'NcoMode[6]': np.uint16, 'NcdMode[6]': np.uint16, #
    'NcoMode[7]': np.uint16, 'NcdMode[7]': np.uint16, #
    'NcoMode[8]': np.uint16, 'NcdMode[8]': np.uint16, #
    'NcoMode[9]': np.uint16, 'NcdMode[9]': np.uint16, # NcdMode[%x]:
    'NcoMode[a]': np.uint16, 'NcdMode[a]': np.uint16, #  Number of coincidence 
    'NcoMode[b]': np.uint16, 'NcdMode[b]': np.uint16, #  generated by CD hit
    'NcoMode[c]': np.uint16, 'NcdMode[c]': np.uint16, #
    'NcoMode[d]': np.uint16, 'NcdMode[d]': np.uint16, #
    'NcoMode[e]': np.uint16, 'NcdMode[e]': np.uint16, #
    'NcoMode[f]': np.uint16, 'NcdMode[f]': np.uint16, #
    'NhitACD'   : np.uint32, # Number of ACD hit
    'NoneSiT'   : np.uint32, # Number of Si-Tracker hit. Any one layer hit (either X or Y signal)
    'NandSiT'   : np.uint32, # Number of Si-Tracker hit. Any one layer hit (both X and Y signal)
    'NtwoSiT'   : np.uint32, # Number of Si-Tracker hit. Any of two layer hit (either X or Y signal)
    'NhitCZT'   : np.uint32, # Number of CZT hit
    'N1stCsI'   : np.uint32, # Number of CsI hit from 1st FEE
    'N2ndCsI'   : np.uint32, # Number of CsI hit form 2nd FEE (Currently disabled)
    'NhitXsi[0]': np.uint32, 'NhitYsi[0]': np.uint32, #
    'NhitXsi[1]': np.uint32, 'NhitYsi[1]': np.uint32, #
    'NhitXsi[2]': np.uint32, 'NhitYsi[2]': np.uint32, #
    'NhitXsi[3]': np.uint32, 'NhitYsi[3]': np.uint32, # NhitXsi[%x]:
    'NhitXsi[4]': np.uint32, 'NhitYsi[4]': np.uint32, #  Number of X-axis hit
    'NhitXsi[5]': np.uint32, 'NhitYsi[5]': np.uint32, #
    'NhitXsi[6]': np.uint32, 'NhitYsi[6]': np.uint32, #
    'NhitXsi[7]': np.uint32, 'NhitYsi[7]': np.uint32, # NhitYsi[%x]:
    'NhitXsi[8]': np.uint32, 'NhitYsi[8]': np.uint32, #  Number of Y-axis hit
    'NhitXsi[9]': np.uint32, 'NhitYsi[9]': np.uint32, #
    'NhitXsi[a]': np.uint32, 'NhitYsi[a]': np.uint32, #
    'NhitXsi[b]': np.uint32, 'NhitYsi[b]': np.uint32, #
    'EoC'       : np.uint32   # EoC: End of Column. Always 0xFFFF FFFF
}

offset = { 
    'UtcTime'   :   0, # UTC Time (datetime64[ns])
    'EventID'   :   2, # EventID + 0x8000 0000 (MSB)
    'NtrgLck'   :   2, # Number of issued Trigger Acknowledge
    'NclkPps'   :   4, # System clock count at GpsPPS received (50MHz)
    'NclkRaw'   :   6, # System clock count (50MHz)
    'NclkEna'   :   8, # System clock count during Trigger Enable (50MHz)
    'NclkLiv'   :  10, # System clock count during Trigger Module is ready (50MHz)
    'NgpsPPS'   :  12, # Number of received GpsPPS signal
    'CoHitRw'   :  15, # Coincidence Hit Flag
    'CoHitCD'   :  14, # Coincidence Count Down Hit Flag
    'HitPatt'   :  16, # Detector Hit Pattern
    'Tsecond'   :  18, # Epoch Time (s) no correction
    'Tmicros'   :  20, # Epoch Time (us) no correction
    'NtrgAck'   :  22, # Number of Trigger Acknowledge 
    'NswtAck'   :  24, # Number of Trigger Acknowledge generated by the switch on board
    'NextAck'   :  26, # Number of Trigger Acknowledge generated by the internal clock
    'NlpcAck'   :  28, # Number of Trigger Acknowledge getenared by the external signal on LPC
    'NhpcAck'   :  30, # Number of Trigger Acknowledge generated by the external signal on HPC
    'NcoMode[0]':  33, 'NcdMode[0]':  32, #
    'NcoMode[1]':  35, 'NcdMode[1]':  34, # 
    'NcoMode[2]':  37, 'NcdMode[2]':  36, #
    'NcoMode[3]':  39, 'NcdMode[3]':  38, # NcoMode[%x]:
    'NcoMode[4]':  41, 'NcdMode[4]':  40, #  Number of coincidence
    'NcoMode[5]':  43, 'NcdMode[5]':  42, #  generated by raw hit
    'NcoMode[6]':  45, 'NcdMode[6]':  44, #
    'NcoMode[7]':  47, 'NcdMode[7]':  46, #
    'NcoMode[8]':  49, 'NcdMode[8]':  49, #
    'NcoMode[9]':  51, 'NcdMode[9]':  50, # NcdMode[%x]:
    'NcoMode[a]':  53, 'NcdMode[a]':  52, #  Number of coincidence 
    'NcoMode[b]':  55, 'NcdMode[b]':  54, #  generated by CD hit
    'NcoMode[c]':  57, 'NcdMode[c]':  56, #
    'NcoMode[d]':  59, 'NcdMode[d]':  58, #
    'NcoMode[e]':  61, 'NcdMode[e]':  60, #
    'NcoMode[f]':  63, 'NcdMode[f]':  62, #
    'NhitACD'   :  64, # Number of ACD hit
    'NoneSiT'   :  66, # Number of Si-Tracker hit. Any one layer hit (either X or Y signal)
    'NandSiT'   :  68, # Number of Si-Tracker hit. Any one layer hit (both X and Y signal)
    'NtwoSiT'   :  70, # Number of Si-Tracker hit. Any of two layer hit (either X or Y signal)
    'NhitCZT'   :  72, # Number of CZT hit
    'N1stCsI'   :  74, # Number of CsI hit from 1st FEE
    'N2ndCsI'   :  76, # Number of CsI hit form 2nd FEE (Currently disabled)
    'NhitXsi[0]':  78, 'NhitYsi[0]':  80, #
    'NhitXsi[1]':  82, 'NhitYsi[1]':  84, #
    'NhitXsi[2]':  86, 'NhitYsi[2]':  88, #
    'NhitXsi[3]':  90, 'NhitYsi[3]':  92, # NhitXsi[%x]:
    'NhitXsi[4]':  94, 'NhitYsi[4]':  96, #  Number of X-axis hit
    'NhitXsi[5]':  98, 'NhitYsi[5]': 100, #
    'NhitXsi[6]': 102, 'NhitYsi[6]': 104, #
    'NhitXsi[7]': 106, 'NhitYsi[7]': 108, # NhitYsi[%x]:
    'NhitXsi[8]': 110, 'NhitYsi[8]': 112, #  Number of Y-axis hit
    'NhitXsi[9]': 114, 'NhitYsi[9]': 116, #
    'NhitXsi[a]': 118, 'NhitYsi[a]': 120, #
    'NhitXsi[b]': 122, 'NhitYsi[b]': 124, #
    'EoC'       : 126   # EoC: End of Column. Always 0xFFFF FFFF
}

def read_hdf5( filename ):
    if os.path.isfile( filename ):
        root,ext = os.path.splitext( filename )
        if ext == '.hdf5':
            df = pd.read_hdf( filename, names=names )
            return df
        else:
            print( "[Warning] File extension \"" + ext + "\" does not match .hdf5" )
    else:
        print( "[Warning] \"" + filename + "\" does not exist" )
    return pd.DataFrame()

def conv_hdf5( filename, force ):
    if os.path.isfile( filename ):
        root,ext = os.path.splitext( filename )
        if ext == '.csv':
            hdf5 = filename.replace( '.csv', '.hdf5' )
            if force and os.path.isfile( hdf5 ):
                os.remove( hdf5 )
            if os.path.isfile( hdf5 ):
                print( "[Warning] \"" + hdf5 + "\" already exist." )
            else:
                print( hdf5 )
                df = pd.read_csv( filename, names=names, dtype=dtype )
                df.to_hdf( hdf5, 'trigger' )
                return df
        elif ext == '.dat':
            hdf5 = filename.replace( '.dat', '.hdf5' )
            if force and os.path.isfile( hdf5 ):
                os.remove( hdf5 )
            if os.path.isfile( hdf5 ):
                print( "[Warning] \"" + hdf5 + "\" already exist." )
            else:
                print( hdf5 )
                df = read_dat( filename )
                if ( df.size == 0 ):
                    print( "[Info] \"" + filename + "\" is empty." )
                else:
                    df.to_hdf( hdf5, 'trigger' )
                return df
        else:
            print( "[Warning] File extension \"" + ext + "\" does not match either .csv or .dat" )
    else:
        print( "[Warning] \"" + filename + "\" does not exist" )
    return pd.DataFrame()

def read_dat( filename ):
    f = open( filename, "rb" )
    ievt = 0;
    dict = {}
    while True:
        event = read_packet( f )
        if event == {}:
            break
        dict[ievt] = event
        ievt += 1
    df = pd.DataFrame.from_dict( dict, "index" )
    column_names = [ 'rang', 'npps', 'corr', 'sync' ];
    dp = pd.DataFrame( columns = column_names )
    dp['rang'] = get_rang( df, dp )
    dp['npps'] = get_npps( df, dp )
    dp['corr'] = get_corr( df, dp )
    dp['sync'] = get_sync( df, dp )
    df['UtcTime'] = det_utcs( df, dp )
    for name in names:
        df[name] = df[name].astype( dtype[name] )
    dp['sync'] = dp['sync'].astype( np.uint32 )
    print( dp )
    return df

def read_packet( f ):
    size_a = get_size( f.read( 2 ) )
    data   = f.read( size_a )
    size_b = get_size( f.read( 2 ) )
    if ( size_a != 0 and size_a == size_b ):
        return data_parse( data )
    else:
        return {}

def data_parse( data ):
    attr = get_attr( data )
    if ( attr == 0xc000 ):
        return parse_trigger( data )
    else:
        print( attr + ' ' + time )
        return {}

def parse_trigger( data ):
    event = {}
    for name in names:
        if name == 'UtcTime':
            event['UtcTime'] = get_time( data )
        elif name == 'EventID':
            event['EventID'] = get_data( data, name ) | 0x80000000
        elif name == 'EoC':
            event['EoC'] = 0xffffffff
        else:
            event[name] = get_data( data, name )
    return event

def get_size( data ):
    if data == b"": return 0
    return ( data[0] << 8 ) + data[1]

def get_attr( data ):
    return ( data[0] << 8 ) + data[1]

def get_time( data ):
    t_sec = ( data[5] << 24 ) + ( data[4] << 16 ) + ( data[3] << 8 ) + ( data[2] )
    t_mic = ( data[9] << 24 ) + ( data[8] << 16 ) + ( data[7] << 8 ) + ( data[6] )
    return t_sec*1000000000 + t_mic*1000

def get_data( data, name ):
    if dtype[name] == np.uint32:
        return get_uint32( data, offset[name] )
    elif dtype[name] == np.uint16:
        return get_uint16( data, offset[name] )
    elif dtype[name] == np.uint64:
        return get_uint64( data, offset[name] )
    else:
        return 0

def get_uint64( data, offset ):
    return 0

def get_uint32( data, offset ):
    addr = 10+2*offset
    return ( data[addr+3] << 24 ) + ( data[addr+2] << 16 ) + ( data[addr+1] << 8 ) + ( data[addr] )
    
def get_uint16( data, offset ):
    addr = 10+2*offset
    return ( data[addr+1] << 8 ) + ( data[addr] )

def get_rang( df, dp ):
    rang = []
    ii = 0;
    tim0 = df['UtcTime'][0]
    for ip in range( len( df.index ) ):
        time = df['UtcTime'][ip]
        if ( time > tim0 + 60000000000 ):
            rang.append( [ ii, ip ] )
            tim0 = time
            ii = ip
    if ( len( rang ) > 0 and time - tim0 < 20000000000 ):
        ii,it = rang.pop()
    rang.append( [ ii, len( df.index ) ] )
    return rang

def get_npps( df, dp ):
    n = []
    for ii, ie in dp['rang']:
        npps = df['NgpsPPS'][ii]
        n.append( npps )
    return n

def get_corr( df, dp ):
    a = []
    SYS_CLOCK = 20.0e-9
    for ii, ie in dp['rang']:
        fpre = df['NclkPps'][ii]
        npps = 0;
        avrg = 0.0
        for ievt in range( ii, ie ):
            fpps = df['NclkPps'][ievt]
            if fpps != fpre:
                if fpps < fpre:
                    nclk = 0x100000000+fpps-fpre
                else:
                    nclk = fpps-fpre
                nsec = np.rint( nclk*SYS_CLOCK )
                if nsec > 0:
                    avrg += nclk*SYS_CLOCK/nsec
                    npps += 1
                    fpre = fpps
        if npps > 0:
            avrg /= npps
            if avrg == 0:
                avrg = 1.0
            a.append( 1.0/avrg )
    return a

def get_sync( df, dp ):
    b = []
    SYS_CLOCK = 20.0e-9
    for i in range( len( dp.index ) ):
        ii,ie = dp['rang'][i]
        corr  = dp['corr'][i];
        sync  = 0.0
        pps0  = df['NclkPps'][ii]
        tim0  = df['UtcTime'][ii] / 1000000000.0
        for ievt in range( ii, ie ):
            fraw = df['NclkRaw'][ievt]
            time = df['UtcTime'][ievt] / 1000000000.0
            if fraw < pps0:
                nclk = 0x100000000+fraw-pps0
            else:
                nclk = fraw-pps0
            diff = time - tim0 - nclk*SYS_CLOCK*corr
            if diff < sync:
                sync = diff
        sync += tim0
        b.append( np.rint( sync ) )
    return b

def det_utcs( df, dp ):
    utcs = []
    SYS_CLOCKns = 20.0
    for i in range( len( dp.index ) ):
        ii,ie = dp['rang'][i]
        fpps = df['NclkPps'][ii]
        for ievt in range( ii, ie ):
            fraw = df['NclkRaw'][ievt]
            if fraw < fpps:
                nclk = 0x100000000+fraw-fpps
            else:
                nclk = fraw-fpps
            utcd = nclk*SYS_CLOCKns*dp['corr'][i] + dp['sync'][i]*1.0e9
            utcs.append( np.rint( utcd ) )
    return utcs
